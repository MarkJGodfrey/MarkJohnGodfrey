<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./resources/CSS/index.css">
    <script src="mjgodfrey.js"></script>
    <title>Projects</title>
</head>
<body>
    <header>
        <h1>Mark Godfrey</h1>
        <nav>
            <div></div>
            <a href="index.html"><p id="first-nav">About Me</p></a>
            <a href="index.html#skills"><p>Skills</p></a>
            <a href="contact.html"><p id="last-nav">Contact</p></a>
        </nav>
    </header>
    <main>
        <section id="projectsintro">
            <h2>Projects</h2>
            <br>
            <p>Over the years I have worked on a multitude of programming projects. The first substantial projects I worked on were for my university courses, and as such were generally motivated by problems mathematical in nature. For instance, one such project required me to write a program that calculated estimates of the area of the Mandelbrot set (a famous fractal shaped set of numbers in the complex plane). Another project had me writing code to simulate games of Monopoly to analyse the frequency with which each space is landed on.</p>
            <br>
            <div>
                <p>Since leaving university, many of the projects I have worked on have been motivated by spontaneous thoughts and general curiosity. for example I've written a program that finds words in the english dictionary that when rotated by 180 degrees, read as either the same word (e.g. SWIMS) or another word (e.g. salem rotated 180 degrees can become wales provided the font has certain properties).</p>
                <div id="swimscont">
                    <img src="./resources/images/projects/SWIMS.png" id="SWIMS" onclick="rotate()">
                </div>
            </div>
            <br>
            <br>
        </section>
        <section id="dithering">
            <h3>Dithering Algorithms</h3>
            <br>
            <div id="trees">
                <div>
                    <p>The largest project I have worked on began with an idea in 2020. I was thinking about a feature of a videogame I had played. The feature was essentially a box where the player is able to write their signature. The box is white by default and the pen colour is black, those are the only available colours. I wondered how someone might go about drawing something more elaborate than a signature, like an image. I was aware of the concept of binary images, but the only method I knew of creating them was the basic threshold algorithm (in which each pixel's colour is converted to whichever colour out of black and white is closest). The problem with this method is that it is quite poor at representing colours with medium brightness, resulting in a substantial loss in detail (figures 1 and 2 demonstrate this).</p>
                    <br>
                    <p>My first attempt at solving this problem was an algorithm that instead of simply approximating each pixel then moving on (losing detail), would scan down the columns of the image keeping a running total of the brightness values. On each pixel, if the total is less than 1 (the brightness value of white), the current pixel is set to black. If the cumulative brightness value is greater than 1, the pixel is set to white, and the cumulative brightness is decremented by 1. This cumulative approach preserves a lot more image detail (the result can be seen in figure 3).</p>
                </div>
                <div id="treescont">
                    <figure>
                        <img src="./resources/images/projects/trees2.png">
                        <figcaption>Figure 1: original forest image</figcaption>
                    </figure>
                    <figure>
                        <img src="./resources/images/projects/trees2bwthreshold.png">
                        <figcaption>Figure 2: binary image created using thresholding</figcaption>
                    </figure>
                    <figure>
                        <img src="./resources/images/projects/trees2bwcumulative.png">
                        <figcaption>Figure 3: binary image created using cumulative brightness</figcaption>
                    </figure>
                </div>
            </div>
            <br>
            <p>Next I wanted to see if I could extend these ideas to cases where the colour palette contains more than just black and white. For my colour palette I decided to use the library of opaque colours that Lego make their bricks in. Humans are generally able to subconsciously recognise fine details on human faces, so I decided using a familiar face as the subject of my test image would allow for rigorous testing of my algorithms.</p>
            <br>
            <div id="messi">
                <div id="messicont">
                    <figure>
                        <img src="./resources/images/projects/LionelMessiOriginal.png">
                        <figcaption>Figure 4: original portrait of Messi</figcaption>
                    </figure>
                    <figure>
                        <img src="./resources/images/projects/legothreshold.png">
                        <figcaption>Figure 5: Lego palette image created using thresholding</figcaption>
                    </figure>
                    <figure>
                        <img src="./resources/images/projects/legopairthreshold.png">
                        <figcaption>Figure 6: Lego palette image created using thresholding on pixel pairs</figcaption>
                    </figure>
                    <figure>
                        <img src="./resources/images/projects/legocumulativergb.png">
                        <figcaption>Figure 7: Lego palette image created using my cumulative RGB algorithm</figcaption>
                    </figure>
                    <figure>
                        <img src="./resources/images/projects/legofloydsteinberg.png">
                        <figcaption>Figure 8: Lego palette image created using Floyd-Steinberg dithering</figcaption>
                    </figure>
                    <figure>
                        <img src="./resources/images/projects/rubikfloydsteinberg.png">
                        <figcaption>Figure 9: Rubik's cube palette image created using Floyd-Steinberg dithering</figcaption>
                    </figure>
                    <figure>
                        <img src="./resources/images/projects/rubikclippedfloydsteinberg.png">
                        <figcaption>Figure 10: Rubik's cube palette image created using colour clipping and Floyd-Steinberg dithering</figcaption>
                    </figure>
                    <figure>
                        <img src="./resources/images/projects/rubikmodifiedfloydsteinberg.png">
                        <figcaption>Figure 11: Rubik's cube palette image created using my modified Floyd-Steinberg algorithm</figcaption>
                    </figure>
                    <figure>
                        <img src="./resources/images/projects/rubikclippedmodifiedfloydsteinberg.png">
                        <figcaption>Figure 12: Rubik's cube palette image created using colour clipping and my modified Floyd-Steinberg algorithm</figcaption>
                    </figure>
                    <figure>
                        <img src="./resources/images/projects/rubiklightmappedclippedmodifiedfloydsteinberg.png">
                        <figcaption>Figure 13: Rubik's cube palette image created using lightness mapping, colour clipping and my modified Floyd-Steinberg algorithm</figcaption>
                    </figure>
                    <figure>
                        <img src="./resources/images/projects/legomodifiedfloydsteinberg.png">
                        <figcaption>Figure 14: Lego palette image created using my modified Floyd-Steinberg algorithm</figcaption>
                    </figure>
                </div>
                <div id="messitext">
                    <p>Figure 4 shows a portrait of Argentine footballer Lionel Messi, this would serve as the image I hope to reproduce. The first algorithm I tried was the basic threshold algorithm, figure 5 shows the results of this. Clearly, even with a colour palette of 41 colours, while a lot of the important details are preserved, the colours leave a lot to be desired.</p>
                    <br>
                    <p>The next approach I took was to use the threshold algorithm on pairs of pixels. The idea being that instead of approximating individual pixels with the nearest palette colour, I would be approximating pairs of pixels with the nearest combination of two palette colours (which can be calculated by averaging the RGB values). In essence, this increases the palette size from 41 colours to 820 colours. Once the two palette colours are selected for each pixel pair, the order in which the pixels are placed in the output image can be chosen in such a way that the appearance of visual artefacts (e.g. clusters of dark pixels) is minimised. This ordering results in a checkerboard-like pattern where light and dark pixels alternate. The result of this algorithm can be seen in figure 6. While this is a significant improvement on standard thresholding, many of the problems that were present in figure 5 are still present here. Namely, there are areas where there are sudden colour changes (most noticeable in the background). Also, because the colour selection process involves taking averages, there are pixels in the resulting image that are very different in colour to the corresponding pixel in the original. This property, while potentially appealing to certain artistic tastes, is not desirable in the pursuit of realism.</p>
                    <br>
                    <p>The cumulative brightness method demonstrated in figure 3 proved a good way to minimise the appearance of sudden colour changes in the binary case, so I wanted to elaborate this method to the polychromatic case. I used a similar idea to that used for the brightness in the cumulative brightness algorithm, and applied it to the individual colour channels (RGB). This new cumulative RGB method adds the cumulative RGB values to each pixel colour before approximating it with the palette colour closest to this modified pixel colour (with the requirement that the RGB values of the chosen palette colour must be less than or equal to those of the modified pixel colour). The selected palette colour's RGB values are taken away from those of the modified pixel colour's and the remainder is then recorded as the new cumulative RGB values to be added to the next pixel. The result of this algorithm can be seen in figure 7. You can see that the colours, in general, look accurate and smooth. However there are glaring issues with the result. At the time, I couldn't figure out what was causing these problems, so I did some research into indexed colour images which led me to dithering algorithms. A dithering algorithm (in computer graphics) is one that makes use of a limited number of colours and distributes them in such a way as to give the illusion of greater colour depth. I hadn't known it up to that point, but the algorithms I had been working on were examples of dithering algorithms. Not only that, the cumulative RGB algorithm that I had come up with, made use of what is referred to in the industry as error diffusion, and was very similar in concept to the most popular industry standard dithering algorithm, the Floyd-Steinberg algorithm.</p>
                    <br>
                    <p>The Floyd-Steinberg algorithm is similar to my cumulative RGB algorithm in that it spreads remainders to the next pixel. Where it differs is, in the Floyd-Steinberg algorithm, they are spread to all of the neighbouring pixels that have yet to be approximated. Also the algorithm does not restrict the selectable palette colours to those with RGB values less than or equal to the modified pixel colour. What this means is the remainders after taking the palette colour from the modified colour can be negative, and are referred to as quantisation errors. The spreading of the quantisation errors is referred to as error diffusion. The results of the Floyd-Steinberg algorithm can be seen in figure 8. Comparing this to the previous algorithm, it's clear that this is the superior algorithm. Colour changes appear smoother, and certain colour inaccuracies have been corrected (most noticeably around the ear). However, there are still problems. Messi's ear and hair just above the ear have a purple hue to them. And above the shoulders, a drooping effect can be seen in the background colours. After some research I found that the problem was being caused by limitations of the colour palette. In this case the problems with the image are minor because the colour palette I used covers a vast range of the colour spectrum. If I change the colour palette to one with fewer colours, covering a smaller range, the problems become a lot more prominent.</p>
                    <br>
                    <p>Figure 9 shows the result of the Floyd-Steinberg algorithm when the colour palette contains only the colours of the faces of a Rubik's cube (namely red, green, blue, yellow, orange, and white). The problems with this image are the same as those with figure 8, just a lot more extreme. To give a brief explanation of what's going wrong, many of the colours in the original image can't be created by blending the Rubik's cube colours. Take the hair for example. Black and brown colours aren't available, so the closest colour the algorithm can produce is a purple. Purple contains more blue than brown does. So scanning down the image, by the time the scan reaches Messi's forehead, the image has too much blue in it. The colour we would expect to see most of in the forehead would be white. White is achieved on a computer screen by maxing out the red green and blue colour channels. The algorithm doesn't 'want' to add any more blue though, as there's already too much in the image. So instead, the colours green and red are added to the forehead, which is why his forehead appears olive green. So the algorithm is working as intended, but producing what looks like an overcompensation in colour. The way this problem is usually solved is by adjusting the colours of the original image so that they are inside the spectrum of colours creatable with the palette (this process is known as colour gamut mapping).</p>
                    <br>
                    <p>After doing some research, I was able to write a gamut mapping algorithm of my own. The results of using this algorithm on the original image, then using the Floyd-Steinberg algorithm can be seen in figure 10. Comparing this to figure 9, it does seem that gamut mapping has fixed all of the major problems that occurred when using the Floyd-Steinberg algorithm on its own.</p>
                    <br>
                    <p>While I was trying to get to sleep one night, I had a moment of inspiration. An idea how I might reduce the appearance of overcompensation of colour. So I modified the Floyd-Steinberg algorithm the next day. Figure 11 shows the results of my modified Floyd-Steinberg algorithm without the use of any gamut mapping algorithms. In this case the result is not quite as good as that of the original Floyd-Steinberg with gamut mapping, but I do find it remarkable that a simple modification to the Floyd-Steinberg algorithm has eliminated the need for a mapping algorithm. It's worth mentioning here that the problems with the original Floyd-Steinberg algorithm have a sort of cascading knock-on effect, where pixels approximated later on in the algorithm, in general are approximated less accurately. As a result, running larger images through the original Floyd-Steinberg algorithm can have a poorer result. This issue doesn't seem to be present in my modified Floyd-Steinberg algorithm, having tested it with quite large images.</p>
                    <br>
                    <p>For those curious, I have included the result of using the same colour gamut mapping algorithm used for figure 10 with the modified Floyd-Steinberg algorithm. This can be seen in figure 12.</p>
                    <br>
                    <p>Figure 13 shows the result of the modified Floyd-Steinberg algorithm with a slightly different gamut mapping. I included this to demonstrate that it is possible to get more accurate hues out of the dithering algorithm, but it usually comes at a cost. In this case, the image has a slightly reduced contrast.</p>
                    <br>
                    <p>Finally, Figure 14 shows the result of my modified Floyd-Steinberg algorithm using the palette of Lego colours again (without any colour gamut mapping). As you can see, the purple ear and hair are no longer. As is the drooping effect in the background. I didn't include any images using the Lego palette and a gamut mapping algorithm with the modified Floyd-Steinberg algorithm because the results were almost indistinguishable from this.</p>    
                </div>
            </div>
        </section>
    </main>
    
</body>
</html>

